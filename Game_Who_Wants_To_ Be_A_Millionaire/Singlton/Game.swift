

import Foundation

//MARK: Game
class Game {
    static let shared = Game()
    
    var gameSession: GameSession?
    
    var difficulty: Difficulty = .consistently
    
    var questionOrderStrategy: QuestionOrderStrategy {
        switch self.difficulty {
        case .consistently:
            return ConsistentlyQuestion()
        case .mixed:
            return MixedQuestion()
        }
    }
    private var recordsCaretaker = RecordsCaretaker()
    var result: [Int]? {
        return gameSession?.recordAnswer
    }
    private(set) var records: [Record] {
        didSet {
            recordsCaretaker.save(self.records)
        }
    }
    /// addRecord
    func addRecord(_ record: Record) {
        records.append(record)
    }
    /// clearRecords
    func clearRecords() {
        records = []
    }
    /// init
    init() {
        self.records = self.recordsCaretaker.retrieveRecords()
    }
}


/*

 3. Добавьте на экран игры лейбл, в котором будет указан номер текущего вопроса и сколько процентов от общего числа вопросов уже получили правильный ответ. С помощью observer (используйте обертку Observable<Type>; если сложно, воспользуйтесь NotificationCenter), следите за этими данными (в вашей архитектуре они должны быть в объекте GameSession) и отображайте на экране в лейбле.
 4. Реализуйте в приложении возможность самому добавить новый вопрос. На экран меню поместите еще одну кнопку — «Добавить вопрос». При нажатии на нее открывается новый экран с формой ввода вопроса. Пользователь заполняет поля, нажимает «Добавить», и этот вопрос добавляется в игру в дополнение к уже существующим (дополнительно: если делали подсказки в модели вопроса, то их поведение сгенерируйте случайным образом — то есть юзер не должен задавать эти поля). Используя паттерн memento, добавьте еще один Caretaker для того, чтобы сохранять созданные юзером вопросы на диск и использовать их при последующих запусках приложения.
 5. * Задание на паттерн Builder. Экран добавления вопроса реализуйте в виде вью-контроллера с table view. Форма заполнения вопроса — это ячейка UITableView с текстовыми полями. Внизу table view добавьте кнопку в виде плюса, при нажатии на которую к table view добавится еще одна ячейка с формой ввода вопроса. Кнопка «Добавить» должна добавлять в приложение не один вопрос, а массив вопросов. Создание массива новых вопросов из введенных на экране данных реализуйте с помощью builder. Билдер при вызове функции build() должен вернуть именно массив вопросов. Сам билдер можно хранить и использовать прямо во время работы программы — когда юзер что-то ввел, у билдера вызвали соответствующий метод.
 6. ** Задание на паттерн Facade. Реализуйте возможность использовать подсказки «Звонок другу», «Помощь зала» и «50/50», если еще не сделали этого (в скобках с пометкой «дополнительно» в предыдущих заданиях были описаны шаги по созданию этой функциональности). В самой игре юзер при ответе на вопрос может нажать на одну из трех кнопок с подсказками. При этом нужно обратиться к модели текущего вопроса и вызвать у него одно из поведений при подсказке. Закройте доступ к этим подсказкам фасадом, применив паттерн facade. У GameSession добавьте свойство с фасадом HintUsageFacade. Этот фасад должен хранить свойство «текущий вопрос», и у него должны быть методы callFriend(), useAuditoryHelp(), use50to50Hint(). Подумайте, как лучше архитектурно реализовать использование этого фасада и как он будет передавать результат вызова метода наружу, во вью-контроллер. Это задание с двумя звездами — здесь вам нужно самостоятельно решить архитектурную задачу!
 */
